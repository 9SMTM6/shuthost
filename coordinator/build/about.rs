use cargo_about;
use krates::Utf8PathBuf as PathBuf;
use serde::{Deserialize, Serialize};
use serde_json;
use spdx::expression::Expression;
use spdx::{LicenseItem, Licensee};
use std::collections::{BTreeMap, BTreeSet, HashMap};
use std::fs::read_to_string;
use url::Url;

#[derive(Deserialize)]
struct DenyConfig {
    licenses: Licenses,
}

#[derive(Deserialize)]
struct Licenses {
    allow: Vec<String>,
}

fn about_config() -> eyre::Result<cargo_about::licenses::config::Config> {
    let deny: DenyConfig = toml::from_str(&include_str!("../../deny.toml"))?;
    let accepted: Vec<Licensee> = deny
        .licenses
        .allow
        .into_iter()
        .map(|s| s.parse::<Licensee>().expect("valid license"))
        .collect();

    Ok(cargo_about::licenses::config::Config {
        accepted,
        targets: vec![
            "x86_64-unknown-linux-gnu".to_string(),
            "aarch64-unknown-linux-gnu".to_string(),
            "x86_64-unknown-linux-musl".to_string(),
            "aarch64-unknown-linux-musl".to_string(),
            "x86_64-apple-darwin".to_string(),
            "aarch64-apple-darwin".to_string(),
        ],
        ..Default::default()
    })
}

#[derive(Serialize)]
enum Ecosystem {
    Rust,
    Npm,
}

#[derive(Serialize)]
struct CombinedEntry {
    name: String,
    version: String,
    ecosystem: Ecosystem,
    #[serde(serialize_with = "serialize_license")]
    license: Expression,
    /// Authors for Rust crates, Publisher for npm packages
    authors_or_publisher: Vec<String>,
    repository: Option<Url>,
}

fn serialize_license<S>(license: &Expression, serializer: S) -> Result<S::Ok, S::Error>
where
    S: serde::Serializer,
{
    let s = license.to_string();
    serializer.serialize_str(&s)
}

fn parse_url(should_be_url: Option<&str>) -> Result<Option<Url>, eyre::Error> {
    Ok(match should_be_url {
        Some(r) => Some(Url::parse(&r).map_err(|e| eyre::eyre!("invalid repository url {}", e))?),
        None => None,
    })
}

// For now, skip direct spdx::text lookups (varies by spdx crate version).
// We will fall back to reading license files where available.
fn get_spdx_text(id: &str) -> Option<String> {
    // spdx::text exports LICENSE_TEXTS: &[(&str, &str)]
    for &(k, v) in spdx::text::LICENSE_TEXTS.iter() {
        if k == id {
            return Some(v.to_string());
        }
    }
    None
}

pub fn collect_deps() -> eyre::Result<()> {
    let manifest_path = PathBuf::from("../Cargo.toml");

    let cfg = about_config()?;

    let krates = cargo_about::get_all_crates(
        &manifest_path,
        false,  // no_default_features
        false,  // all_features
        vec![], // features
        true,   // workspace
        krates::LockOptions {
            frozen: false,
            locked: false,
            offline: false,
        },
        &cfg,
        &vec![], // target
    )
    .map_err(|e| eyre::eyre!("{e}"))?;

    // collect crate entries and license texts map
    let mut combined = Vec::<CombinedEntry>::new();
    let mut licenses_set = BTreeSet::<LicenseItem>::new();

    for k in krates.krates() {
        let license_str = k
            .license
            .clone()
            .ok_or_else(|| eyre::eyre!("crate '{}' has no license", k.name))?;

        // parse into SPDX expression, fail if invalid
        let expr: Expression = license_str
            .parse()
            .map_err(|e| eyre::eyre!("invalid SPDX expression for crate {}: {e}", k.name))?;

        // collect license ids from the expression requirements
        for er in expr.requirements() {
            licenses_set.insert(er.req.license.clone());
        }

        // version may be semver::Version or string-like; format to string
        let version = k.version.to_string();

        combined.push(CombinedEntry {
            name: k.name.clone(),
            version,
            ecosystem: Ecosystem::Rust,
            license: expr,
            authors_or_publisher: k.authors.clone(),
            repository: parse_url(k.repository.as_deref())?,
        });
    }

    // read npm license json (generated by frontend build)
    // parse npm JSON into typed struct map
    #[derive(Deserialize)]
    struct NpmInfo {
        licenses: Option<String>,
        license: Option<String>,
        repository: Option<String>,
        publisher: Option<String>,
        #[serde(flatten)]
        _other: HashMap<String, serde_json::Value>,
    }

    let npm_map: HashMap<String, NpmInfo> = serde_json::from_str(&read_to_string(
        "../frontend/assets/generated/npm-licenses.json",
    )?)?;
    for (pkgkey, info) in npm_map.into_iter() {
        let license_str = info
            .licenses
            .or(info.license)
            .ok_or_else(|| eyre::eyre!("npm package '{}' missing license", pkgkey))?;

        // parse SPDX expression and ensure we have texts for each requirement
        let expr: Expression = license_str
            .parse()
            .map_err(|e| eyre::eyre!("invalid SPDX expression for npm package {}: {e}", pkgkey))?;

        for er in expr.requirements() {
            licenses_set.insert(er.req.license.clone());
        }

        // split pkgkey into name and version using last '@'
        let (name, version) = if let Some(idx) = pkgkey.rfind('@') {
            let (n, v) = pkgkey.split_at(idx);
            // v starts with '@', drop it
            (n.to_string(), v[1..].to_string())
        } else {
            (pkgkey.clone(), String::from(""))
        };

        combined.push(CombinedEntry {
            name,
            version,
            ecosystem: Ecosystem::Npm,
            license: expr,
            authors_or_publisher: info.publisher.map(|p| vec![p]).unwrap_or_else(|| vec![]),
            repository: parse_url(info.repository.as_deref())?,
        });
    }

    let licenses_map: BTreeMap<_, _> = licenses_set
        .iter()
        .map(|itm| {
            (
                itm.to_string(),
                get_spdx_text(&itm.to_string()).expect("License text should be available"),
            )
        })
        .collect();

    // produce output with combined entries and separate license texts map
    let out = serde_json::json!({
        "entries": combined,
        "licenses": licenses_map,
    });
    let json = serde_json::to_string_pretty(&out)?;
    std::fs::write("../frontend/assets/generated/combined_licenses.json", &json)?;

    Ok(())
}
