//! Database operations for persisting application state.
//!
//! This module handles SQLite database operations for persisting leases and other state.

use std::{collections::HashMap, path::Path};

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use sqlx::{Sqlite, SqlitePool, migrate::MigrateDatabase};

use crate::http::m2m::{LeaseMap, LeaseSource};

/// Database connection pool type alias.
#[expect(
    clippy::module_name_repetitions,
    reason = "Just using 'Pool' would be harder to understand."
)]
pub type DbPool = SqlitePool;

/// Represents a lease record from the database.
struct LeaseRecord {
    hostname: String,
    lease_source_type: String,
    lease_source_value: Option<String>,
}

/// Represents a key-value record from the database.
#[derive(sqlx::FromRow)]
struct KvRecord {
    value: String,
}

/// Represents a client stats record from the database.
#[derive(sqlx::FromRow)]
struct ClientStatsRecord {
    client_id: String,
    last_used: Option<chrono::NaiveDateTime>,
}

// Keys used in the kv_store table for persisted autogenerated auth values.
pub const KV_COOKIE_SECRET: &str = "cookie_secret";
pub const KV_AUTH_TOKEN: &str = "auth_token";
pub const KV_VAPID_PRIVATE_KEY: &str = "vapid_private_key";
pub const KV_VAPID_PUBLIC_KEY: &str = "vapid_public_key";

/// Client statistics for tracking usage metrics.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClientStats {
    pub last_used: Option<DateTime<Utc>>,
}

/// Creates or opens the SQLite database and runs migrations.
///
/// # Arguments
///
/// * `db_path` - Path to the SQLite database file.
///
/// # Returns
///
/// A database connection pool.
///
/// # Errors
///
/// Returns an error if the database cannot be created or migrated.
pub async fn init(db_path: &Path) -> eyre::Result<DbPool> {
    let db_url = format!("sqlite:{}", db_path.display());

    // Create database if it doesn't exist
    if !Sqlite::database_exists(&db_url).await? {
        Sqlite::create_database(&db_url).await?;
    }

    let pool = SqlitePool::connect(&db_url).await?;

    // Run migrations
    sqlx::migrate!("./migrations").run(&pool).await?;

    Ok(pool)
}

/// Loads all leases from the database into the in-memory map.
///
/// # Arguments
///
/// * `pool` - Database connection pool.
/// * `leases` - The in-memory lease map to populate.
///
/// # Errors
///
/// Returns an error if the database query fails.
pub async fn load_leases(pool: &DbPool, leases: &LeaseMap) -> eyre::Result<()> {
    let mut leases_guard = leases.lock().await;

    // Clear existing leases
    leases_guard.clear();

    // Load all lease records
    let lease_records = sqlx::query_as!(
        LeaseRecord,
        "SELECT hostname, lease_source_type, lease_source_value FROM leases"
    )
    .fetch_all(pool)
    .await?;

    for row in lease_records {
        let hostname = row.hostname;
        let lease_source_type = row.lease_source_type;
        let lease_source_value = row.lease_source_value;

        let lease_source = match lease_source_type.as_str() {
            "web_interface" => LeaseSource::WebInterface,
            "client" => LeaseSource::Client(lease_source_value.unwrap_or_default()),
            _ => continue, // Skip invalid records
        };

        leases_guard
            .entry(hostname)
            .or_default()
            .insert(lease_source);
    }

    Ok(())
}

/// Persists a lease change to the database.
///
/// # Arguments
///
/// * `pool` - Database connection pool.
/// * `hostname` - The hostname for the lease.
/// * `lease_source` - The lease source being added or removed.
/// * `action` - "add" to add the lease, "remove" to remove it.
///
/// # Errors
///
/// Returns an error if the database operation fails.
pub async fn add_lease(
    pool: &DbPool,
    hostname: &str,
    lease_source: &LeaseSource,
) -> eyre::Result<()> {
    match *lease_source {
        LeaseSource::WebInterface => {
            sqlx::query!(
                "INSERT OR IGNORE INTO web_interface_leases (hostname) VALUES (?)",
                hostname
            )
            .execute(pool)
            .await?;
        }
        LeaseSource::Client(ref client_id) => {
            sqlx::query!(
                "INSERT OR IGNORE INTO client_leases (hostname, client_id) VALUES (?, ?)",
                hostname,
                client_id
            )
            .execute(pool)
            .await?;
        }
    }
    Ok(())
}

/// Removes a lease from the database for the specified hostname and lease source.
///
/// # Arguments
///
/// * `pool` - Database connection pool
/// * `hostname` - The hostname for which to remove the lease
/// * `lease_source` - The source of the lease (web interface or specific client)
///
/// # Errors
///
/// This function will return an error if the database operation fails.
pub async fn remove_lease(
    pool: &DbPool,
    hostname: &str,
    lease_source: &LeaseSource,
) -> eyre::Result<()> {
    match *lease_source {
        LeaseSource::WebInterface => {
            sqlx::query!(
                "DELETE FROM web_interface_leases WHERE hostname = ?",
                hostname
            )
            .execute(pool)
            .await?;
        }
        LeaseSource::Client(ref client_id) => {
            sqlx::query!(
                "DELETE FROM client_leases WHERE hostname = ? AND client_id = ?",
                hostname,
                client_id
            )
            .execute(pool)
            .await?;
        }
    }
    Ok(())
}

/// Removes all leases for a specific client from the database.
///
/// # Arguments
///
/// * `pool` - Database connection pool.
/// * `client_id` - The client ID whose leases should be removed.
///
/// # Errors
///
/// Returns an error if the database operation fails.
pub async fn remove_client_leases(pool: &DbPool, client_id: &str) -> eyre::Result<()> {
    sqlx::query!("DELETE FROM client_leases WHERE client_id = ?", client_id)
        .execute(pool)
        .await?;

    Ok(())
}

/// Stores a key-value pair in the database.
///
/// # Arguments
///
/// * `pool` - Database connection pool.
/// * `key` - The key to store.
/// * `value` - The value to store.
///
/// # Errors
///
/// Returns an error if the database operation fails.
pub async fn store_kv(pool: &DbPool, key: &str, value: &str) -> eyre::Result<()> {
    sqlx::query!(
        "INSERT OR REPLACE INTO kv_store (key, value) VALUES (?, ?)",
        key,
        value
    )
    .execute(pool)
    .await?;

    Ok(())
}

/// Retrieves a value from the key-value store.
///
/// # Arguments
///
/// * `pool` - Database connection pool.
/// * `key` - The key to retrieve.
///
/// # Returns
///
/// The value associated with the key, or None if not found.
///
/// # Errors
///
/// Returns an error if the database query fails.
pub async fn get_kv(pool: &DbPool, key: &str) -> eyre::Result<Option<String>> {
    let result = sqlx::query_as!(KvRecord, "SELECT value FROM kv_store WHERE key = ?", key)
        .fetch_optional(pool)
        .await?;

    Ok(result.map(|r| r.value))
}

/// Removes a key-value pair from the database.
///
/// # Arguments
///
/// * `pool` - Database connection pool.
/// * `key` - The key to remove.
///
/// # Errors
///
/// Returns an error if the database operation fails.
pub async fn delete_kv(pool: &DbPool, key: &str) -> eyre::Result<()> {
    sqlx::query!("DELETE FROM kv_store WHERE key = ?", key)
        .execute(pool)
        .await?;

    Ok(())
}

/// Retrieves statistics for all clients.
///
/// # Arguments
///
/// * `pool` - Database connection pool.
///
/// # Returns
///
/// A map of client_id to ClientStats.
///
/// # Errors
///
/// Returns an error if the database query fails.
pub async fn get_all_client_stats(pool: &DbPool) -> eyre::Result<HashMap<String, ClientStats>> {
    let records = sqlx::query_as!(
        ClientStatsRecord,
        "SELECT client_id, last_used FROM client_stats"
    )
    .fetch_all(pool)
    .await?;

    Ok(records
        .into_iter()
        .map(|rec| {
            (
                rec.client_id,
                ClientStats {
                    last_used: rec
                        .last_used
                        .map(|dt| DateTime::<Utc>::from_naive_utc_and_offset(dt, Utc)),
                },
            )
        })
        .collect())
}

/// Retrieves statistics for a specific client.
/// This function is only used in tests.
#[expect(
    clippy::missing_errors_doc,
    reason = "This function is only used in tests."
)]
pub async fn get_client_stats(pool: &DbPool, client_id: &str) -> eyre::Result<Option<ClientStats>> {
    let result = sqlx::query_as!(
        ClientStatsRecord,
        "SELECT client_id, last_used FROM client_stats WHERE client_id = ?",
        client_id
    )
    .fetch_optional(pool)
    .await?;

    Ok(result.map(|r| ClientStats {
        last_used: r
            .last_used
            .map(|dt| DateTime::<Utc>::from_naive_utc_and_offset(dt, Utc)),
    }))
}

/// Updates the last_used timestamp for a client.
///
/// # Arguments
///
/// * `pool` - Database connection pool.
/// * `client_id` - The client ID to update.
/// * `last_used` - The new last used timestamp.
///
/// # Errors
///
/// Returns an error if the database operation fails.
pub async fn update_client_last_used(
    pool: &DbPool,
    client_id: &str,
    last_used: DateTime<Utc>,
) -> eyre::Result<()> {
    sqlx::query!(
        "INSERT OR REPLACE INTO client_stats (client_id, last_used) VALUES (?, ?)",
        client_id,
        last_used
    )
    .execute(pool)
    .await?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use sqlx::Row;
    use std::collections::HashMap;
    use std::collections::HashSet;
    use std::sync::Arc;
    use tokio::sync::Mutex;

    async fn setup_test_db() -> eyre::Result<DbPool> {
        init(std::path::Path::new(":memory:")).await
    }

    #[tokio::test]
    async fn test_init_db_creates_database() {
        let pool = setup_test_db().await.unwrap();

        // Verify we can query the database
        let result = sqlx::query("SELECT name FROM sqlite_master WHERE type IN ('table', 'view')")
            .fetch_all(&pool)
            .await
            .unwrap();

        // Should have our tables and view
        let names: HashSet<_> = result.into_iter().map(|r| r.get::<String, _>(0)).collect();
        assert!(names.contains("web_interface_leases"));
        assert!(names.contains("client_leases"));
        assert!(names.contains("leases"));
        assert!(names.contains("client_stats"));
    }

    #[tokio::test]
    async fn test_add_and_load_leases() {
        let pool = setup_test_db().await.unwrap();
        let leases: LeaseMap = Arc::new(Mutex::new(HashMap::new()));

        // Initially empty
        load_leases(&pool, &leases).await.unwrap();
        assert!(leases.lock().await.is_empty());

        // Add web interface lease
        add_lease(&pool, "host1", &LeaseSource::WebInterface)
            .await
            .unwrap();

        // Add client lease
        add_lease(&pool, "host1", &LeaseSource::Client("client1".to_string()))
            .await
            .unwrap();
        add_lease(&pool, "host2", &LeaseSource::Client("client1".to_string()))
            .await
            .unwrap();

        // Load and verify
        load_leases(&pool, &leases).await.unwrap();
        let leases_guard = leases.lock().await;

        assert_eq!(leases_guard.len(), 2);
        assert!(leases_guard["host1"].contains(&LeaseSource::WebInterface));
        assert!(leases_guard["host1"].contains(&LeaseSource::Client("client1".to_string())));
        assert!(leases_guard["host2"].contains(&LeaseSource::Client("client1".to_string())));
    }

    #[tokio::test]
    async fn test_remove_lease() {
        let pool = setup_test_db().await.unwrap();
        let leases: LeaseMap = Arc::new(Mutex::new(HashMap::new()));

        // Add leases
        add_lease(&pool, "host1", &LeaseSource::WebInterface)
            .await
            .unwrap();
        add_lease(&pool, "host1", &LeaseSource::Client("client1".to_string()))
            .await
            .unwrap();

        // Remove web interface lease
        remove_lease(&pool, "host1", &LeaseSource::WebInterface)
            .await
            .unwrap();

        // Load and verify
        load_leases(&pool, &leases).await.unwrap();
        let leases_guard = leases.lock().await;

        assert_eq!(leases_guard.len(), 1);
        assert!(leases_guard["host1"].contains(&LeaseSource::Client("client1".to_string())));
        assert!(!leases_guard["host1"].contains(&LeaseSource::WebInterface));
    }

    #[tokio::test]
    async fn test_remove_client_leases() {
        let pool = setup_test_db().await.unwrap();
        let leases: LeaseMap = Arc::new(Mutex::new(HashMap::new()));

        // Add client leases
        add_lease(&pool, "host1", &LeaseSource::Client("client1".to_string()))
            .await
            .unwrap();
        add_lease(&pool, "host2", &LeaseSource::Client("client1".to_string()))
            .await
            .unwrap();
        add_lease(&pool, "host3", &LeaseSource::Client("client2".to_string()))
            .await
            .unwrap();

        // Remove all for client1
        remove_client_leases(&pool, "client1").await.unwrap();

        // Load and verify
        load_leases(&pool, &leases).await.unwrap();
        let leases_guard = leases.lock().await;

        assert_eq!(leases_guard.len(), 1);
        assert!(leases_guard["host3"].contains(&LeaseSource::Client("client2".to_string())));
    }

    #[tokio::test]
    async fn test_duplicate_leases_ignored() {
        let pool = setup_test_db().await.unwrap();
        let leases: LeaseMap = Arc::new(Mutex::new(HashMap::new()));

        // Add same lease twice
        add_lease(&pool, "host1", &LeaseSource::WebInterface)
            .await
            .unwrap();
        add_lease(&pool, "host1", &LeaseSource::WebInterface)
            .await
            .unwrap();

        // Load and verify only one
        load_leases(&pool, &leases).await.unwrap();
        let leases_guard = leases.lock().await;

        assert_eq!(leases_guard.len(), 1);
        assert_eq!(leases_guard["host1"].len(), 1);
        assert!(leases_guard["host1"].contains(&LeaseSource::WebInterface));
    }

    #[tokio::test]
    async fn test_store_and_get_kv() {
        let pool = setup_test_db().await.unwrap();

        // Store a value
        store_kv(&pool, "test_key", "test_value").await.unwrap();

        // Retrieve it
        let value = get_kv(&pool, "test_key").await.unwrap();
        assert_eq!(value, Some("test_value".to_string()));

        // Try to get non-existent key
        let missing = get_kv(&pool, "missing_key").await.unwrap();
        assert_eq!(missing, None);

        // Update existing key
        store_kv(&pool, "test_key", "updated_value").await.unwrap();
        let updated = get_kv(&pool, "test_key").await.unwrap();
        assert_eq!(updated, Some("updated_value".to_string()));

        // Delete the key
        delete_kv(&pool, "test_key").await.unwrap();
        let deleted = get_kv(&pool, "test_key").await.unwrap();
        assert_eq!(deleted, None);
    }

    #[tokio::test]
    async fn test_client_stats() {
        let pool = setup_test_db().await.unwrap();

        // Initially no stats
        let stats = get_all_client_stats(&pool).await.unwrap();
        assert!(stats.is_empty());

        // Update last used for a client
        let now = Utc::now();
        update_client_last_used(&pool, "client1", now)
            .await
            .unwrap();

        // Get stats for the client
        let client_stats = get_client_stats(&pool, "client1").await.unwrap();
        assert!(client_stats.is_some());
        assert_eq!(client_stats.unwrap().last_used, Some(now));

        // Get all stats
        let all_stats = get_all_client_stats(&pool).await.unwrap();
        assert_eq!(all_stats.len(), 1);
        assert_eq!(all_stats["client1"].last_used, Some(now));

        // Update again
        let later = Utc::now();
        update_client_last_used(&pool, "client1", later)
            .await
            .unwrap();
        let updated = get_client_stats(&pool, "client1").await.unwrap();
        assert_eq!(updated.unwrap().last_used, Some(later));
    }
}
