//! Database operations for persisting application state.
//!
//! This module handles SQLite database operations for persisting leases and other state.

use std::path::Path;

use sqlx::{Sqlite, SqlitePool, migrate::MigrateDatabase};

use crate::http::m2m::{LeaseMap, LeaseSource};

/// Database connection pool type alias.
#[expect(
    clippy::module_name_repetitions,
    reason = "Just using 'Pool' would be harder to understand."
)]
pub type DbPool = SqlitePool;

// Keys used in the kv_store table for persisted autogenerated auth values.
pub const KV_COOKIE_SECRET: &str = "cookie_secret";
pub const KV_AUTH_TOKEN: &str = "auth_token";

/// Creates or opens the SQLite database and runs migrations.
///
/// # Arguments
///
/// * `db_path` - Path to the SQLite database file.
///
/// # Returns
///
/// A database connection pool.
///
/// # Errors
///
/// Returns an error if the database cannot be created or migrated.
pub async fn init(db_path: &Path) -> eyre::Result<DbPool> {
    let db_url = format!("sqlite:{}", db_path.display());

    // Create database if it doesn't exist
    if !Sqlite::database_exists(&db_url).await? {
        Sqlite::create_database(&db_url).await?;
    }

    let pool = SqlitePool::connect(&db_url).await?;

    // Run migrations
    sqlx::migrate!("./migrations").run(&pool).await?;

    Ok(pool)
}

/// Loads all leases from the database into the in-memory map.
///
/// # Arguments
///
/// * `pool` - Database connection pool.
/// * `leases` - The in-memory lease map to populate.
///
/// # Errors
///
/// Returns an error if the database query fails.
pub async fn load_leases(pool: &DbPool, leases: &LeaseMap) -> eyre::Result<()> {
    let mut leases_guard = leases.lock().await;

    // Clear existing leases
    leases_guard.clear();

    // Load all lease records
    let lease_records =
        sqlx::query!("SELECT hostname, lease_source_type, lease_source_value FROM leases")
            .fetch_all(pool)
            .await?;

    for row in lease_records {
        let hostname: String = row.hostname;
        let lease_source_type: String = row.lease_source_type;
        let lease_source_value: Option<String> = row.lease_source_value;

        let lease_source = match lease_source_type.as_str() {
            "web_interface" => LeaseSource::WebInterface,
            "client" => LeaseSource::Client(lease_source_value.unwrap_or_default()),
            _ => continue, // Skip invalid records
        };

        leases_guard
            .entry(hostname)
            .or_default()
            .insert(lease_source);
    }

    Ok(())
}

/// Persists a lease change to the database.
///
/// # Arguments
///
/// * `pool` - Database connection pool.
/// * `hostname` - The hostname for the lease.
/// * `lease_source` - The lease source being added or removed.
/// * `action` - "add" to add the lease, "remove" to remove it.
///
/// # Errors
///
/// Returns an error if the database operation fails.
pub async fn add_lease(
    pool: &DbPool,
    hostname: &str,
    lease_source: &LeaseSource,
) -> eyre::Result<()> {
    match *lease_source {
        LeaseSource::WebInterface => {
            sqlx::query!(
                "INSERT OR IGNORE INTO web_interface_leases (hostname) VALUES (?)",
                hostname
            )
            .execute(pool)
            .await?;
        }
        LeaseSource::Client(ref client_id) => {
            sqlx::query!(
                "INSERT OR IGNORE INTO client_leases (hostname, client_id) VALUES (?, ?)",
                hostname,
                client_id
            )
            .execute(pool)
            .await?;
        }
    }
    Ok(())
}

/// Removes a lease from the database for the specified hostname and lease source.
///
/// # Arguments
///
/// * `pool` - Database connection pool
/// * `hostname` - The hostname for which to remove the lease
/// * `lease_source` - The source of the lease (web interface or specific client)
///
/// # Errors
///
/// This function will return an error if the database operation fails.
pub async fn remove_lease(
    pool: &DbPool,
    hostname: &str,
    lease_source: &LeaseSource,
) -> eyre::Result<()> {
    match *lease_source {
        LeaseSource::WebInterface => {
            sqlx::query!(
                "DELETE FROM web_interface_leases WHERE hostname = ?",
                hostname
            )
            .execute(pool)
            .await?;
        }
        LeaseSource::Client(ref client_id) => {
            sqlx::query!(
                "DELETE FROM client_leases WHERE hostname = ? AND client_id = ?",
                hostname,
                client_id
            )
            .execute(pool)
            .await?;
        }
    }
    Ok(())
}

/// Removes all leases for a specific client from the database.
///
/// # Arguments
///
/// * `pool` - Database connection pool.
/// * `client_id` - The client ID whose leases should be removed.
///
/// # Errors
///
/// Returns an error if the database operation fails.
pub async fn remove_client_leases(pool: &DbPool, client_id: &str) -> eyre::Result<()> {
    sqlx::query!("DELETE FROM client_leases WHERE client_id = ?", client_id)
        .execute(pool)
        .await?;

    Ok(())
}

/// Stores a key-value pair in the database.
///
/// # Arguments
///
/// * `pool` - Database connection pool.
/// * `key` - The key to store.
/// * `value` - The value to store.
///
/// # Errors
///
/// Returns an error if the database operation fails.
pub async fn store_kv(pool: &DbPool, key: &str, value: &str) -> eyre::Result<()> {
    sqlx::query!(
        "INSERT OR REPLACE INTO kv_store (key, value) VALUES (?, ?)",
        key,
        value
    )
    .execute(pool)
    .await?;

    Ok(())
}

/// Retrieves a value from the key-value store.
///
/// # Arguments
///
/// * `pool` - Database connection pool.
/// * `key` - The key to retrieve.
///
/// # Returns
///
/// The value associated with the key, or None if not found.
///
/// # Errors
///
/// Returns an error if the database query fails.
pub async fn get_kv(pool: &DbPool, key: &str) -> eyre::Result<Option<String>> {
    let result = sqlx::query!("SELECT value FROM kv_store WHERE key = ?", key)
        .fetch_optional(pool)
        .await?;

    Ok(result.map(|r| r.value))
}

/// Removes a key-value pair from the database.
///
/// # Arguments
///
/// * `pool` - Database connection pool.
/// * `key` - The key to remove.
///
/// # Errors
///
/// Returns an error if the database operation fails.
pub async fn delete_kv(pool: &DbPool, key: &str) -> eyre::Result<()> {
    sqlx::query!("DELETE FROM kv_store WHERE key = ?", key)
        .execute(pool)
        .await?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use sqlx::Row;
    use std::collections::HashMap;
    use std::collections::HashSet;
    use std::sync::Arc;
    use tokio::sync::Mutex;

    async fn setup_test_db() -> eyre::Result<DbPool> {
        init(std::path::Path::new(":memory:")).await
    }

    #[tokio::test]
    async fn test_init_db_creates_database() {
        let pool = setup_test_db().await.unwrap();

        // Verify we can query the database
        let result = sqlx::query("SELECT name FROM sqlite_master WHERE type IN ('table', 'view')")
            .fetch_all(&pool)
            .await
            .unwrap();

        // Should have our tables and view
        let names: HashSet<_> = result.into_iter().map(|r| r.get::<String, _>(0)).collect();
        assert!(names.contains("web_interface_leases"));
        assert!(names.contains("client_leases"));
        assert!(names.contains("leases"));
    }

    #[tokio::test]
    async fn test_add_and_load_leases() {
        let pool = setup_test_db().await.unwrap();
        let leases: LeaseMap = Arc::new(Mutex::new(HashMap::new()));

        // Initially empty
        load_leases(&pool, &leases).await.unwrap();
        assert!(leases.lock().await.is_empty());

        // Add web interface lease
        add_lease(&pool, "host1", &LeaseSource::WebInterface)
            .await
            .unwrap();

        // Add client lease
        add_lease(&pool, "host1", &LeaseSource::Client("client1".to_string()))
            .await
            .unwrap();
        add_lease(&pool, "host2", &LeaseSource::Client("client1".to_string()))
            .await
            .unwrap();

        // Load and verify
        load_leases(&pool, &leases).await.unwrap();
        let leases_guard = leases.lock().await;

        assert_eq!(leases_guard.len(), 2);
        assert!(leases_guard["host1"].contains(&LeaseSource::WebInterface));
        assert!(leases_guard["host1"].contains(&LeaseSource::Client("client1".to_string())));
        assert!(leases_guard["host2"].contains(&LeaseSource::Client("client1".to_string())));
    }

    #[tokio::test]
    async fn test_remove_lease() {
        let pool = setup_test_db().await.unwrap();
        let leases: LeaseMap = Arc::new(Mutex::new(HashMap::new()));

        // Add leases
        add_lease(&pool, "host1", &LeaseSource::WebInterface)
            .await
            .unwrap();
        add_lease(&pool, "host1", &LeaseSource::Client("client1".to_string()))
            .await
            .unwrap();

        // Remove web interface lease
        remove_lease(&pool, "host1", &LeaseSource::WebInterface)
            .await
            .unwrap();

        // Load and verify
        load_leases(&pool, &leases).await.unwrap();
        let leases_guard = leases.lock().await;

        assert_eq!(leases_guard.len(), 1);
        assert!(leases_guard["host1"].contains(&LeaseSource::Client("client1".to_string())));
        assert!(!leases_guard["host1"].contains(&LeaseSource::WebInterface));
    }

    #[tokio::test]
    async fn test_remove_client_leases() {
        let pool = setup_test_db().await.unwrap();
        let leases: LeaseMap = Arc::new(Mutex::new(HashMap::new()));

        // Add client leases
        add_lease(&pool, "host1", &LeaseSource::Client("client1".to_string()))
            .await
            .unwrap();
        add_lease(&pool, "host2", &LeaseSource::Client("client1".to_string()))
            .await
            .unwrap();
        add_lease(&pool, "host3", &LeaseSource::Client("client2".to_string()))
            .await
            .unwrap();

        // Remove all for client1
        remove_client_leases(&pool, "client1").await.unwrap();

        // Load and verify
        load_leases(&pool, &leases).await.unwrap();
        let leases_guard = leases.lock().await;

        assert_eq!(leases_guard.len(), 1);
        assert!(leases_guard["host3"].contains(&LeaseSource::Client("client2".to_string())));
    }

    #[tokio::test]
    async fn test_duplicate_leases_ignored() {
        let pool = setup_test_db().await.unwrap();
        let leases: LeaseMap = Arc::new(Mutex::new(HashMap::new()));

        // Add same lease twice
        add_lease(&pool, "host1", &LeaseSource::WebInterface)
            .await
            .unwrap();
        add_lease(&pool, "host1", &LeaseSource::WebInterface)
            .await
            .unwrap();

        // Load and verify only one
        load_leases(&pool, &leases).await.unwrap();
        let leases_guard = leases.lock().await;

        assert_eq!(leases_guard.len(), 1);
        assert_eq!(leases_guard["host1"].len(), 1);
        assert!(leases_guard["host1"].contains(&LeaseSource::WebInterface));
    }

    #[tokio::test]
    async fn test_store_and_get_kv() {
        let pool = setup_test_db().await.unwrap();

        // Store a value
        store_kv(&pool, "test_key", "test_value").await.unwrap();

        // Retrieve it
        let value = get_kv(&pool, "test_key").await.unwrap();
        assert_eq!(value, Some("test_value".to_string()));

        // Try to get non-existent key
        let missing = get_kv(&pool, "missing_key").await.unwrap();
        assert_eq!(missing, None);

        // Update existing key
        store_kv(&pool, "test_key", "updated_value").await.unwrap();
        let updated = get_kv(&pool, "test_key").await.unwrap();
        assert_eq!(updated, Some("updated_value".to_string()));

        // Delete the key
        delete_kv(&pool, "test_key").await.unwrap();
        let deleted = get_kv(&pool, "test_key").await.unwrap();
        assert_eq!(deleted, None);
    }
}
