//! Database operations for persisting application state.
//!
//! This module handles `SQLite` database operations for persisting leases and other state.

use std::{collections::HashMap, path::Path};

#[cfg(unix)]
use std::os::unix::fs::PermissionsExt as _;

use chrono::{DateTime, Utc};
use eyre::Context as _;
use serde::{Deserialize, Serialize};
use sqlx::{Sqlite, SqlitePool, migrate::MigrateDatabase as _};
use tracing::{error, warn};

use crate::http::m2m::{LeaseMap, LeaseSource};

/// Database connection pool type alias.
// This lint seems to have false negatives with pub(crate)
// #[expect(
//     clippy::module_name_repetitions,
//     reason = "Just using 'Pool' would be harder to understand."
// )]
pub(crate) type DbPool = SqlitePool;

/// Represents a lease record from the database.
struct LeaseRecord {
    hostname: String,
    lease_source_type: String,
    lease_source_value: Option<String>,
}

/// Represents a key-value record from the database.
#[derive(sqlx::FromRow)]
struct KvRecord {
    value: String,
}

/// Represents a client stats record from the database.
#[derive(sqlx::FromRow)]
struct ClientStatsRecord {
    client_id: String,
    last_used: Option<chrono::NaiveDateTime>,
}

// Keys used in the kv_store table for persisted autogenerated auth values.
pub(crate) const KV_COOKIE_SECRET: &str = "cookie_secret";
pub(crate) const KV_AUTH_TOKEN: &str = "auth_token";

/// Client statistics for tracking usage metrics.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClientStats {
    pub last_used: Option<DateTime<Utc>>,
}

#[cfg(unix)]
#[expect(
    clippy::absolute_paths,
    reason = "we don't want to add a bunch of imports behind cfg attributes"
)]
fn check_file_permissions(path: &Path, expected_mode: u32) {
    if let Ok(metadata) = std::fs::metadata(path) {
        let mode = metadata.permissions().mode() & 0o777;
        if mode != expected_mode {
            warn!(
                "File {} has permissions {:o}, which are not restrictive. Expected {:o}.",
                path.display(),
                mode,
                expected_mode
            );
        }
    } else {
        warn!("Could not check permissions of file {}", path.display());
    }
}

/// Creates or opens the `SQLite` database and runs migrations.
///
/// # Arguments
///
/// * `db_path` - Path to the `SQLite` database file.
///
/// # Returns
///
/// A database connection pool.
///
/// # Errors
///
/// Returns an error if the database cannot be created or migrated.
pub(crate) async fn init(db_path: &Path) -> eyre::Result<DbPool> {
    let db_url = format!("sqlite:{}", db_path.display());

    // Create database if it doesn't exist
    if !Sqlite::database_exists(&db_url).await? {
        Sqlite::create_database(&db_url).await?;
    }

    let pool = DbPool::connect(&db_url).await?;

    // Run migrations
    sqlx::migrate!("./migrations")
        .run(&pool)
        .await
        .wrap_err(format!(
            "Failed to run database migrations on: {}",
            db_path.display()
        ))?;

    #[cfg(unix)]
    {
        check_file_permissions(db_path, 0o600);
        let wal_path = db_path.with_extension("db-wal");
        if wal_path.exists() {
            check_file_permissions(&wal_path, 0o600);
        }
        let shm_path = db_path.with_extension("db-shm");
        if shm_path.exists() {
            check_file_permissions(&shm_path, 0o600);
        }
    }

    Ok(pool)
}

/// Loads all leases from the database into the in-memory map.
///
/// # Arguments
///
/// * `pool` - Database connection pool.
/// * `leases` - The in-memory lease map to populate.
///
/// # Errors
///
/// Returns an error if the database query fails.
pub(crate) async fn load_leases(pool: &DbPool, leases: &LeaseMap) -> eyre::Result<()> {
    let mut leases_guard = leases.lock().await;

    // Clear existing leases
    leases_guard.clear();

    // Load all lease records
    let lease_records = sqlx::query_as!(
        LeaseRecord,
        "SELECT hostname, lease_source_type, lease_source_value FROM leases"
    )
    .fetch_all(pool)
    .await
    .map_err(|e| {
        error!("Failed to load leases from database: {}", e);
        e
    })?;

    for row in lease_records {
        let hostname = row.hostname;
        let lease_source_type = row.lease_source_type;
        let lease_source_value = row.lease_source_value;

        let lease_source = match lease_source_type.as_str() {
            "web_interface" => LeaseSource::WebInterface,
            "client" => LeaseSource::Client(lease_source_value.unwrap_or_default()),
            _ => {
                warn!(
                    "Skipping invalid lease record with type: {}",
                    lease_source_type
                );
                continue;
            }
        };

        leases_guard
            .entry(hostname)
            .or_default()
            .insert(lease_source);
    }

    Ok(())
}

/// Persists a lease to the database.
///
/// # Arguments
///
/// * `pool` - Database connection pool.
/// * `hostname` - The hostname for the lease.
/// * `lease_source` - The lease source to persist.
///
/// # Errors
///
/// Returns an error if the database operation fails.
pub(crate) async fn add_lease(
    pool: &DbPool,
    hostname: &str,
    lease_source: &LeaseSource,
) -> eyre::Result<()> {
    match *lease_source {
        LeaseSource::WebInterface => {
            sqlx::query!(
                "INSERT OR IGNORE INTO web_interface_leases (hostname) VALUES (?)",
                hostname
            )
            .execute(pool)
            .await
            .map_err(|e| {
                error!(
                    %e, hostname, "Failed to persist web interface lease"
                );
                e
            })?;
        }
        LeaseSource::Client(ref client_id) => {
            sqlx::query!(
                "INSERT OR IGNORE INTO client_leases (hostname, client_id) VALUES (?, ?)",
                hostname,
                client_id
            )
            .execute(pool)
            .await
            .map_err(|e| {
                error!(
                    %e, hostname, client_id, "Failed to persist client lease"
                );
                e
            })?;
        }
    }
    Ok(())
}

/// Removes a lease from the database for the specified hostname and lease source.
///
/// # Arguments
///
/// * `pool` - Database connection pool
/// * `hostname` - The hostname for which to remove the lease
/// * `lease_source` - The source of the lease (web interface or specific client)
///
/// # Errors
///
/// This function will return an error if the database operation fails.
pub(crate) async fn remove_lease(
    pool: &DbPool,
    hostname: &str,
    lease_source: &LeaseSource,
) -> eyre::Result<()> {
    match *lease_source {
        LeaseSource::WebInterface => {
            sqlx::query!(
                "DELETE FROM web_interface_leases WHERE hostname = ?",
                hostname
            )
            .execute(pool)
            .await
            .map_err(|e| {
                error!(
                    %e, hostname, "Failed to remove web interface lease"
                );
                e
            })?;
        }
        LeaseSource::Client(ref client_id) => {
            sqlx::query!(
                "DELETE FROM client_leases WHERE hostname = ? AND client_id = ?",
                hostname,
                client_id
            )
            .execute(pool)
            .await
            .map_err(|e| {
                error!(
                    %e, hostname, client_id, "Failed to remove client lease"
                );
                e
            })?;
        }
    }
    Ok(())
}

/// Removes all leases for a specific client from the database.
///
/// # Arguments
///
/// * `pool` - Database connection pool.
/// * `client_id` - The client ID whose leases should be removed.
///
/// # Errors
///
/// Returns an error if the database operation fails.
pub(crate) async fn remove_client_leases(pool: &DbPool, client_id: &str) -> eyre::Result<()> {
    sqlx::query!("DELETE FROM client_leases WHERE client_id = ?", client_id)
        .execute(pool)
        .await
        .map_err(|e| {
            error!(
                %e, client_id, "Failed to remove client leases"
            );
            e
        })?;

    Ok(())
}

/// Stores a key-value pair in the database.
///
/// # Arguments
///
/// * `pool` - Database connection pool.
/// * `key` - The key to store.
/// * `value` - The value to store.
///
/// # Errors
///
/// Returns an error if the database operation fails.
pub(crate) async fn store_kv(pool: &DbPool, key: &str, value: &str) -> eyre::Result<()> {
    sqlx::query!(
        "INSERT OR REPLACE INTO kv_store (key, value) VALUES (?, ?)",
        key,
        value
    )
    .execute(pool)
    .await
    .map_err(|e| {
        error!(
            %e, key, value, "Failed to store key-value pair"
        );
        e
    })?;

    Ok(())
}

/// Retrieves a value from the key-value store.
///
/// # Arguments
///
/// * `pool` - Database connection pool.
/// * `key` - The key to retrieve.
///
/// # Returns
///
/// The value associated with the key, or None if not found.
///
/// # Errors
///
/// Returns an error if the database query fails.
pub(crate) async fn get_kv(pool: &DbPool, key: &str) -> eyre::Result<Option<String>> {
    let result = sqlx::query_as!(KvRecord, "SELECT value FROM kv_store WHERE key = ?", key)
        .fetch_optional(pool)
        .await
        .map_err(|e| {
            error!(%e, key, "Failed to retrieve key-value pair");
            e
        })?;

    Ok(result.map(|r| r.value))
}

/// Removes a key-value pair from the database.
///
/// # Arguments
///
/// * `pool` - Database connection pool.
/// * `key` - The key to remove.
///
/// # Errors
///
/// Returns an error if the database operation fails.
pub(crate) async fn delete_kv(pool: &DbPool, key: &str) -> eyre::Result<()> {
    sqlx::query!("DELETE FROM kv_store WHERE key = ?", key)
        .execute(pool)
        .await
        .map_err(|e| {
            error!(%e, key, "Failed to delete key-value pair");
            e
        })?;

    Ok(())
}

/// Retrieves statistics for all clients.
///
/// # Arguments
///
/// * `pool` - Database connection pool.
///
/// # Returns
///
/// A map of `client_id` to `ClientStats`.
///
/// # Errors
///
/// Returns an error if the database query fails.
pub(crate) async fn get_all_client_stats(
    pool: &DbPool,
) -> eyre::Result<HashMap<String, ClientStats>> {
    let records = sqlx::query_as!(
        ClientStatsRecord,
        "SELECT client_id, last_used FROM client_stats"
    )
    .fetch_all(pool)
    .await
    .map_err(|e| {
        error!(%e, "Failed to retrieve client stats");
        e
    })?;

    Ok(records
        .into_iter()
        .map(|rec| {
            (
                rec.client_id,
                ClientStats {
                    last_used: rec
                        .last_used
                        .map(|dt| DateTime::<Utc>::from_naive_utc_and_offset(dt, Utc)),
                },
            )
        })
        .collect())
}

/// Retrieves statistics for a specific client.
// this lint seems to have false negatives with pub(crate)
// #[expect(
//     clippy::missing_errors_doc,
//     reason = "This function is only used in tests."
// )]
#[cfg_attr(
    not(test),
    expect(dead_code, reason = "This function is only used in tests.")
)]
pub(crate) async fn get_client_stats(
    pool: &DbPool,
    client_id: &str,
) -> eyre::Result<Option<ClientStats>> {
    let result = sqlx::query_as!(
        ClientStatsRecord,
        "SELECT client_id, last_used FROM client_stats WHERE client_id = ?",
        client_id
    )
    .fetch_optional(pool)
    .await
    .map_err(|e| {
        error!(%e, client_id, "Failed to retrieve client stats");
        e
    })?;

    Ok(result.map(|r| ClientStats {
        last_used: r
            .last_used
            .map(|dt| DateTime::<Utc>::from_naive_utc_and_offset(dt, Utc)),
    }))
}

/// Updates the `last_used` timestamp for a client.
///
/// # Arguments
///
/// * `pool` - Database connection pool.
/// * `client_id` - The client ID to update.
/// * `last_used` - The new last used timestamp.
///
/// # Errors
///
/// Returns an error if the database operation fails.
pub(crate) async fn update_client_last_used(
    pool: &DbPool,
    client_id: &str,
    last_used: DateTime<Utc>,
) -> eyre::Result<()> {
    sqlx::query!(
        "INSERT OR REPLACE INTO client_stats (client_id, last_used) VALUES (?, ?)",
        client_id,
        last_used
    )
    .execute(pool)
    .await
    .map_err(|e| {
        error!(
            %e, client_id, %last_used, "Failed to update client last used timestamp"
        );
        e
    })?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use alloc::sync::Arc;
    use sqlx::Row as _;
    use std::collections::HashMap;
    use std::collections::HashSet;
    use tokio::sync::Mutex;

    async fn setup_test_db() -> eyre::Result<DbPool> {
        init(Path::new(":memory:")).await
    }

    #[tokio::test]
    async fn init_db_creates_database() {
        let pool = setup_test_db().await.unwrap();

        // Verify we can query the database
        let result = sqlx::query("SELECT name FROM sqlite_master WHERE type IN ('table', 'view')")
            .fetch_all(&pool)
            .await
            .unwrap();

        // Should have our tables and view
        let names: HashSet<_> = result.into_iter().map(|r| r.get::<String, _>(0)).collect();
        assert!(names.contains("web_interface_leases"));
        assert!(names.contains("client_leases"));
        assert!(names.contains("leases"));
        assert!(names.contains("client_stats"));
    }

    #[tokio::test]
    async fn add_and_load_leases() {
        let pool = setup_test_db().await.unwrap();
        let leases: LeaseMap = Arc::new(Mutex::new(HashMap::new()));

        // Initially empty
        load_leases(&pool, &leases).await.unwrap();
        assert!(leases.lock().await.is_empty());

        // Add web interface lease
        add_lease(&pool, "host1", &LeaseSource::WebInterface)
            .await
            .unwrap();

        // Add client lease
        add_lease(&pool, "host1", &LeaseSource::Client("client1".to_string()))
            .await
            .unwrap();
        add_lease(&pool, "host2", &LeaseSource::Client("client1".to_string()))
            .await
            .unwrap();

        // Load and verify
        load_leases(&pool, &leases).await.unwrap();
        let leases_guard = leases.lock().await;

        assert_eq!(leases_guard.len(), 2);
        assert!(leases_guard["host1"].contains(&LeaseSource::WebInterface));
        assert!(leases_guard["host1"].contains(&LeaseSource::Client("client1".to_string())));
        assert!(leases_guard["host2"].contains(&LeaseSource::Client("client1".to_string())));
    }

    #[tokio::test]
    async fn remove_lease_works() {
        let pool = setup_test_db().await.unwrap();
        let leases: LeaseMap = Arc::new(Mutex::new(HashMap::new()));

        // Add leases
        add_lease(&pool, "host1", &LeaseSource::WebInterface)
            .await
            .unwrap();
        add_lease(&pool, "host1", &LeaseSource::Client("client1".to_string()))
            .await
            .unwrap();

        // Remove web interface lease
        remove_lease(&pool, "host1", &LeaseSource::WebInterface)
            .await
            .unwrap();

        // Load and verify
        load_leases(&pool, &leases).await.unwrap();
        let leases_guard = leases.lock().await;

        assert_eq!(leases_guard.len(), 1);
        assert!(leases_guard["host1"].contains(&LeaseSource::Client("client1".to_string())));
        assert!(!leases_guard["host1"].contains(&LeaseSource::WebInterface));
    }

    #[tokio::test]
    async fn remove_client_leases_works() {
        let pool = setup_test_db().await.unwrap();
        let leases: LeaseMap = Arc::new(Mutex::new(HashMap::new()));

        // Add client leases
        add_lease(&pool, "host1", &LeaseSource::Client("client1".to_string()))
            .await
            .unwrap();
        add_lease(&pool, "host2", &LeaseSource::Client("client1".to_string()))
            .await
            .unwrap();
        add_lease(&pool, "host3", &LeaseSource::Client("client2".to_string()))
            .await
            .unwrap();

        // Remove all for client1
        remove_client_leases(&pool, "client1").await.unwrap();

        // Load and verify
        load_leases(&pool, &leases).await.unwrap();
        let leases_guard = leases.lock().await;

        assert_eq!(leases_guard.len(), 1);
        assert!(leases_guard["host3"].contains(&LeaseSource::Client("client2".to_string())));
    }

    #[tokio::test]
    async fn duplicate_leases_ignored() {
        let pool = setup_test_db().await.unwrap();
        let leases: LeaseMap = Arc::new(Mutex::new(HashMap::new()));

        // Add same lease twice
        add_lease(&pool, "host1", &LeaseSource::WebInterface)
            .await
            .unwrap();
        add_lease(&pool, "host1", &LeaseSource::WebInterface)
            .await
            .unwrap();

        // Load and verify only one
        load_leases(&pool, &leases).await.unwrap();
        let leases_guard = leases.lock().await;

        assert_eq!(leases_guard.len(), 1);
        assert_eq!(leases_guard["host1"].len(), 1);
        assert!(leases_guard["host1"].contains(&LeaseSource::WebInterface));
    }

    #[tokio::test]
    async fn store_and_get_kv() {
        let pool = setup_test_db().await.unwrap();

        // Store a value
        store_kv(&pool, "test_key", "test_value").await.unwrap();

        // Retrieve it
        let value = get_kv(&pool, "test_key").await.unwrap();
        assert_eq!(value, Some("test_value".to_string()));

        // Try to get non-existent key
        let missing = get_kv(&pool, "missing_key").await.unwrap();
        assert_eq!(missing, None);

        // Update existing key
        store_kv(&pool, "test_key", "updated_value").await.unwrap();
        let updated = get_kv(&pool, "test_key").await.unwrap();
        assert_eq!(updated, Some("updated_value".to_string()));

        // Delete the key
        delete_kv(&pool, "test_key").await.unwrap();
        let deleted = get_kv(&pool, "test_key").await.unwrap();
        assert_eq!(deleted, None);
    }

    #[tokio::test]
    async fn client_stats() {
        let pool = setup_test_db().await.unwrap();

        // Initially no stats
        let stats = get_all_client_stats(&pool).await.unwrap();
        assert!(stats.is_empty());

        // Update last used for a client
        let now = Utc::now();
        update_client_last_used(&pool, "client1", now)
            .await
            .unwrap();

        // Get stats for the client
        let client_stats = get_client_stats(&pool, "client1").await.unwrap();
        assert!(client_stats.is_some());
        assert_eq!(client_stats.unwrap().last_used, Some(now));

        // Get all stats
        let all_stats = get_all_client_stats(&pool).await.unwrap();
        assert_eq!(all_stats.len(), 1);
        assert_eq!(all_stats["client1"].last_used, Some(now));

        // Update again
        let later = Utc::now();
        update_client_last_used(&pool, "client1", later)
            .await
            .unwrap();
        let updated = get_client_stats(&pool, "client1").await.unwrap();
        assert_eq!(updated.unwrap().last_used, Some(later));
    }
}
