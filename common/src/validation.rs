//! HMAC validation utilities for verifying signed messages.
//!
//! This module provides functions for validating HMAC signatures and
//! parsing signed messages with timestamp verification.

use crate::signing::{sign_hmac, unix_time_seconds};

/// Allowed time window (in seconds) for which a signed message timestamp is considered valid.
pub const ALLOWED_WINDOW: u64 = 30; // Seconds

/// Result of validating an HMAC-signed message.
#[derive(Debug, PartialEq)]
pub enum HmacValidationResult {
    /// The HMAC and timestamp are valid; contains the original message.
    Valid(String),
    /// The timestamp is outside the allowed time window.
    InvalidTimestamp,
    /// The HMAC signature did not match.
    InvalidHmac,
    /// The message format was malformed.
    MalformedMessage,
}

/// Validates a signed message generated by `create_signed_message`.
///
/// # Arguments
///
/// * `data` - The signed message, expected to be "timestamp|message|signature".
/// * `secret` - The secret key used for HMAC.
///
/// # Returns
///
/// A `HmacValidationResult` indicating if the message is valid or why it failed.
pub fn validate_hmac_message(data: &str, secret: &str) -> HmacValidationResult {
    if let Some((timestamp, message, received_signature)) = parse_hmac_message(data) {
        if !is_timestamp_in_valid_range(timestamp) {
            return HmacValidationResult::InvalidTimestamp;
        }
        if !verify_hmac(
            &format!("{timestamp}|{message}"),
            &received_signature,
            secret,
        ) {
            return HmacValidationResult::InvalidHmac;
        }
        return HmacValidationResult::Valid(message);
    }
    HmacValidationResult::MalformedMessage
}

/// Verifies an HMAC signature against a message.
pub fn verify_hmac(message: &str, received_signature: &str, secret: &str) -> bool {
    received_signature == sign_hmac(message, secret)
}

/// Checks if a timestamp is within the allowed time window.
pub fn is_timestamp_in_valid_range(timestamp: u64) -> bool {
    unix_time_seconds().abs_diff(timestamp) <= ALLOWED_WINDOW
}

/// Parses an HMAC message into its components.
pub fn parse_hmac_message(data: &str) -> Option<(u64, String, String)> {
    let parts: Vec<&str> = data.split('|').collect();
    let &[timestamp_str, message, signature] = parts.as_slice() else {
        return None;
    };
    let timestamp = timestamp_str.parse().ok()?;
    Some((timestamp, message.to_string(), signature.to_string()))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_invalid_hmac() {
        let secret = "mysecret";
        let mut signed = crate::create_signed_message("hello", secret);
        signed.push_str("tampered");
        assert!(matches!(
            validate_hmac_message(&signed, secret),
            HmacValidationResult::InvalidHmac | HmacValidationResult::MalformedMessage
        ));
    }

    #[test]
    fn test_parse_hmac_message() {
        let data = "123|msg|sig";
        let parsed = parse_hmac_message(data);
        assert_eq!(parsed, Some((123, "msg".to_string(), "sig".to_string())));
    }
}
